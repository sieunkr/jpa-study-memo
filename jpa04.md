
-   **고급매핑 - 상속관계 매핑**
    -   개요
        -   객체의 상속 구조와, 데이터베이스의 슈퍼, 서브 타입 관계를 매핑하는 기법
        -   관계형 데이터베이스는 상속 관계가 없지만
        -   슈퍼타입, 서브타입 관계라는 모델링 기법으로 객체 상속과 유사하게 설계 가능
    -   상속관계 매핑 방법 세가지
        -   조인 전략
        -   단일 테이블 전략
        -   구현 클래스마다 테이블 전략
    -   샘플 사례  
    -   주요 어노테이션
        -   '@Inheritance(strategy=InheritanceType.XXX)
            -   JOINED : 조인 전략
            -   SINGLE_TABLE : 단일 테이블 전략
            -   TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
    -   **방법1 : 조인 전략**  
        -   가장 정규화된 방법
        -   장점
            -   테이블 정규화
            -   외래키 참조 무결성 제약조건 활용 가능
            -   저장공간 효율화
        -   단점
            -   조회 시 조인을 사용하기 때문에, 성능 저하 발생할 수 있음
            -   조회 쿼리가 복잡함
            -   데이터 저장시 insert SQL 2번 호출
    -   방법2 : 단일 테이블 전략  
        
        -   논리 모델을 한 테이블에 저장하는 방법
        -   조인 전략이 너무 복잡하다고 판단될 때, 단일 테이블 전략도 괜찮은 방법
        -   장점
            -   조인이 필요 없음, 일반적으로 조회 성능이 빠름
            -   조회 쿼리가 단순함
        -   단점
            -   자식 엔티티가 매핑한 컬럼은 모두 null 허용
            -   단일 테이블에 모든 것을 저장하므로, 테이블이 커질 수 있음
                -   오히려, 성능이 안좋아질수도...
    -   방법 3 : 구현 클래스마다 테이블 전략  
        
        -   장점
            -   서브 타입을 명확하게 구분해야하는 경우 효과적
            -   not null 제약조건 사용 가능
        -   단점
            -   여러 자식 테이블을 함께 조회할 때 성능이 느려짐
                -   SQL 쿼리에서 UNION 을 사용
            -   자식 테이블을 통합해서 쿼리하기 어려움
        -   김영한님 의견
            -   실무에서 사용하면 안됨
    -   정답은 없음
        -   초기 애플리케이션 설계시에는, 객체 지향적으로 설계하면 됨. 단, 추후에 데이터가 엄청 많아지면...(예, 1억 단위 데이터, 하루에 몇백만 건씩 쌓인다면) 그땐, 설계를 다시 고민해봐야할 수도 있다.
-   **고급 매핑 - '@MappedSupurclass'**
    -   테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보가 필요할 때 사용
    -   예) 등록일, 수정일, 등록자, 수정자 등(createdBy, createdDate..)
    -   상속관계 매핑이 아님
    -   엔티티 아님
        -   테이블이 생성되지는 않음
    -   부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공해줌
    -   조회, 검색 불가
        -   엔티티매니저에서 find 할 수 없음
    -   직접 생성해서 사용할 일이 없으므로 추상 클래스 권장
-   **프록시**
    -   em.find() vs em.getReference()
        -   em.find() : 데이터베이스를 통해서 실제 엔티티 객체를 조회
        -   em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 객체 조회
            -   getReference() 를 실행하는 시점에서는, 실제로 데이터베이스에 SQL 쿼리를 하지 않음
            -   JPA 구현체인 하이버네이트가 가짜 프록시를 생성
    -   프록시 특징  
        -   프록시 객체는 처음 사용할 때 한번만 초기화
            -   두번째 부터는 영속성 컨텍스트에 이미 생성한 객체를 사용
        -   프록시 객체를 초기화할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아님
            -   초기화되면 프록시 객체를 통해서 실제 엔티티 접근 가능
        -   프록시 객체는 원본 엔티티를 상속받음, 타입 체크 주의
            -   타입 비교시 == 사용 안됨
            -   대신, instance of 를 사용해야 함
        -   영속성 컨텍스트에 찾는 엔티티가 이미 있으면, em.getReference() 를 호출해도 실제 엔티티 반환
        -   영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시 초기화 문제 발생
    -   프록시 객체의 초기화
        -   
    -   프록시 확인
        -   프록시 인스턴스의 초기화 여부 확인
            -   PersistenceUnitUtil.isLoaded(Object entity)
        -   프록시 클래스 확인 방법
            -   entity.getClass.getName() 출력
                
        -   프록시 강제 초기화
            -   org.hibernate.Hibernate.initialize(entity)
                
-   **즉시 로딩, 지연로딩**
    -   지연로딩
        -   실제 사용하는 시점에서 SQL 쿼리를 실행
        -   그 전에는 프록시 객체를 가져옴
        -   
        -   '@ManyToOne(fetch= FetchType.LAZY) 로 설정하면, 프록시 객체로 조회 함
        -   예) Member m = em.findMember(Member.class, member1.getId())
            -   m.getTeam().getClass → 이때까진 프록시 객체
            -   m.getTeam().getName() → 이때는 데이터베이스에 SQL 을 조회 함
    -   즉시로딩
        -   예)Member 조회 시 거의 항상 Team 정보가 필요한 경우
        -   Join 쿼리를 사용해서 처음부터 한번에, 연관 데이터를 전부 조회 함
        -   프록시 객체를 사용하지 않음
    -   주의
        -   가급적 지연로딩만 사용하자.
        -   즉시 로딩을 적용하면 예상하지 못한 SQL 이 실행
        -   즉시 로딩은 JPQL 에서 N+1 문제가 발생
            -   해결책
                -   모든 연관관계를 지연로딩으로 한다
                -   패치 조인을 사용한다
                -   Entity Graph 를 사용한다.
                -   배치 사이즈? 를 사용한다.
        -   ManyToOne, OneToOne 은 디폴트 값이 즉시로딩..
            -   LAZY 로 설정해서 사용하자.
-   **영속성 전이와 고아 객체**
    -   영속성 전이
        -   개요
            -   특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들 수 있다.
        -   주의
            -   영속성 전이는 연관관계를 매핑하는 것과 아무 연관이 없음
            -   엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.
        -   CASCADE 종류
            -   ALL : 모두 적용
            -   PERSIST : 영속
            -   REMOVE
            -   MERGE
            -   REFRESH
            -   DETACH
        -   하나의 부모가 자식들을 관리할 때는 의미가 있음
        -   쓰면 안되는 케이스
            -   ..?
    -   고아 객체
        -   고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
            
        -   orphanRemoval = true
    -   주의
        -   참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
        -   참조하는 곳이 하나일 때 사용해야 함
        -   특정 엔티티가 개인 소유할 때 사용
        -   @OneToOne, @OneToMany 만 가능
        -   참고
            -   개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서, 고아 객체 제거 기능을 활성화하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascadeType.REMOVE 처럼 동작한다.
    -   영속성 전이 + 고아 객체, 생명주기
        
        -   CascadeType.ALL + orphanRemovel=true
        -   스스로 생명주기를 관리하는 엔티티는 em.persist() 로 영속화, em.remove() 로 제거
        -   두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음
        -   도메인 주도 설계의 Aggregate Root 개념을 구현할 때 유용
-   **값타입**
    -   JPA 의 데이터 타입 분류
        
        -   엔티티 타입
            -   @Entity 로 정의하는 객체
            -   데이터가 변해도 식별자로 지속해서 추적 가능
            -   예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
        -   값 타입
            -   int, integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
            -   식별자가 없고 값만 있으므로 변경시 추적 불가
            -   예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체
    -   구체적인 데이터 타입 분류
        -   기본값 타입  
            -   자바 기본 타입(int, double)
            -   래퍼 클래스(Integer, Long)
            -   String
        -   임베디드 타입
            -   JPA 에서 정의해서 사용해야 한다.
        -   컬렉션 타입
            -   JPA 에서 정의해서 사용
            -   컬렉션에 기본값 또는 임베디드 타입을 넣은 형태
    -   기본값 타입
    -   임베디드 타입
    -   값 타입과 불변 객체
    -   값 타입의 비교
    -   값 타입 컬렉션
