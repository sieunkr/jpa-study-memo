
# JPA 기본, 영속성 관리

## 참고자료 

1. 김영한님 인프런 강의
2. JPA 퀵스타트



 - JPA 기본 
	 - 기술 발전 트렌드
		 - 순수 JDBC
		 - JDBCTemplate
		 - SQL Mapper (MyBatis)
		 - JPA
	 - 기존 개발 방법 : SQL 중심적인 개발의 문제점
		 - 무한 반복, 지루한 코드
		 - SQL 에 의존적인 개발을 피하기 어렵다.
	 - JPA 장점
		 - 개발 생산성 혁신
		 - 개발 속도
		 - 유지보수
	 - JPA 를 실무에서 쉽게 사용하기 어려운 이유
		 - 섣부르게 실무에 도입하면 엄청난 삽질을 할 수 있다.
		 - 객체와 테이블을 올바르게 매핑, 설계를 잘해야 하낟.
		 - JPA 내부 동작 방식을 이해해야 한다. 
		 - JPA 가 어떤 SQL 을 만들어내는지, 언제 실행하는지 반드시 이해해야 한다. 
- JPA 소개
	- JPA
		- Object - Relational Mapping (객체 관계 매핑)
		- 객체는 객체대로 설계, 관계형 데이터베이스는 데이터베이스대로 설계
		- ORM 프레임워크가 중간에서 매핑
		- 대중적인 언어에는 대부분 ORM 기술이 존재한다. 
	- JPA 동작
		- 쿼리를 개발자가 만들지 않는다. JPA 가 대신 만들어줌
		- 패러다임의 불일치 해결
		- 내부적으로는, JDBC API 를 사용함
	- JPA 를 왜 사용하면 좋은가?
		- SQL 중심적인 개발에서 객체 지항 중심의 개발로 전환
		- 생산성
		- 유지보수
		- 패러다임의 불일치 해결
		- 성능
		- 데이터 접근 추상화와 벤더 독립성
		- 표준?
	- JPA 성능 최적화
		- 1차 캐시, 동일성 보장
			- 같은 트랜잭션 안에서는 같은 엔티티를 반환
			- 실무에서 큰 도움은 안됨
		- 트랜잭션을 지원하는 쓰기 지연
			- 트랜잭션을 커밋할 때까지 SQL 을 저장해놨다가 한번에 전송
		- 지연로딩
	- ORM 이란
		- 객체와 관계형 데이터베이스 기둥 뒤에 있는 기술
		- 둘 사이에 균형이 중요하지만, 굳이 선택하면 데이터베이스를 이해하는 것이 더 중요하다. 데이터가 더 오래 살아남기 때문에..
- JPA 구동방식
	- EntityManagerFactory 는 로딩 시점에 하나만 생성한다.
	- 데이터베이스 커넥션을 생성해서 종료할때마다 엔티티 매니저를 만들어야 함
	- 트랜잭션 단위를 설정해야하며, 모든 변경 작업은 트랜잭션 범위 내에서 동작
	- 개발자는 쿼리를 직접 만들지 않고, JPA 가 매핑정보를 보고 알아서 SQL 을 생성한다.
- 영속성 (1)
	- JPA 에서 가장 중요한 개념 두가지
		- 객체와 관계형 데이터베이스를 매핑
		- 영속성 컨텍스트
	- 엔티티매니저팩토리
		- 요청이 있을때마다 엔티티매니저를 생성한다.
	- 엔티티매니저
		- 데이터베이스에 커넥션을 맺고, 작업을 요청한다.
		- 엔티티매니저를 사용해서, 영속성 컨텍스트에 접근
	- 영속성 컨텍스트(컨테이너)
		- 엔티티를 영구적으로 저장하는 환경
		- 논리적인 개념
		- 영속 컨텍스트는 EntityManagerFactory 로 부터 EntityManager 객체를 획득할 때 내부적으로 생성되며, 엔티티매니저를 통해서만 영속성 컨텍스트에 접근할 수있다. 
	- 엔티티 생명주기
		- 비영속 : 엔티티가 영속 컨텍스트에 등록되지 않은 상태
		- 영속 : 엔티티가 영속 컨텍스트에 등록되었고, 관리되는 상태
		- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
		- 삭제 : 엔티티가 영속 컨텍스트에서 삭제 처리된 상태
	- 트랜잭션
		- 트랜잭션이 커밋되는 시점에서, 영속성 컨텍스트에서 관리하는 엔티티의 변경사항이 쿼리로 호출됨
	- 영속 컨텍스트의 이점
		- 1차 캐시
		- 동일성 보장
		- 트랜잭션을 지원하는 쓰기 지연
		- 변경 감지 (Dirty Checking)
		- 지연 로딩
- 영속성 (2)
	- 1차 캐시
		- 키: id, 값 : 엔티티 객체 자체
		- 1차 캐시에 있으면, 캐시 값을 사용.
		- 1차 캐시에 없다면, 데이터베이스에서 조회해서 사용하고 1차 캐시에 저장
		- 실제로 실무에서는 큰 도움은 안된다고 함, 트랜잭션이 끝나면 영속성 컨텍스트를 지움. 1차 캐시도 없어짐 - 김영한님 의견
	- 동일성 보장
	- 트랜잭션을 지원하는 쓰기 지연
		- 커밋하는 순간 데이터베이스에 쓰기 지연 저장소에 저장되어있던 	SQL 을 같이 보낸다. 
	- 엔티티 변경 감지
		- 트랜잭션 커밋을 하면, 엔티티와 스냅샷을 비교한 후 변경사항이 있다면 업데이트 쿼리를 데이터베이스에 요청한다.
	- 플러시
		- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
		- 플러시가 발생하면 무슨일이?
			- 변경 감지
			- 수정된 엔티티 쓰기 지연 SQL 저장소 등록
			- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송
		- 영속성 컨텍스트를 플러시하는 방법
			- entityManager.flush 직접 호출
			- 트랜잭션 커밋
			- JPQL 쿼리 실행
		- 플러시는..
			- 영속성 컨텍스트를 비우지 않음
			- 컨텍스트 내 엔티티의 변경 내용을 데이터베이스에 동기화
			- 트랜잭션 단위 중요
